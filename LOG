From lcc 4.0 to 4.1:

Changes:

See doc/4.html for changes in the code-generation interface.

Warns about constants that are too large, eg, short x = 70000;

Unsigned shorts are now used for wide-character constants, and
wchar_t is a typedef for unsigned short.

On the SPARC, lcc now emits .type and .size directives
unconditionally.

On the x86, constants are now emitted into the text segment.

Errors fixed:

Erroneously complained about unknown sizes for some const fields, eg,
typedef struct foo ref; struct foo { const ref *q; int a; };
f(ref *p, int i) { return p->q[i].a; }

-A -A erroneously complained about static main's that didn't conform
to the ANSI-mandated "int main(void)" or "int main(int, char **)".

Silently generated incorrect code for a structure copy with a
post-incremented target, eg, struct { int x; } data = {1}, copy[2],
*q = copy; main() { *q++ = data; }

Generated incorrect values in some expressions with constant pointers.

Silently truncated string literals longer than 4095 characters.

Failed to emit debugging information for uninitialized globals.

Failed to diagnose missing sizes in some multi-dimensioned array
declarators, eg, extern int x[][10]; int x[5][];

Silently emitted incorrect sizes and initalizations for some
incomplete multi-dimensioned arrays involving pointers and whose size
is determined by the number of initializers.

On the MIPS, sometimes generated an incorrect frame size and thus a
crash when floating-point registers were saved.

On the SPARC, erroneously reused a register variable as a temporary
when the variable is compiler-generated.

On the SPARC with -b, emitted incorrect code for returning structs.

On the x86, conversion from float to int rounded instead of truncated
with the default floating-point mode.

$Id$
