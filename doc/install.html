<HEADER>
<TITLE>Installing lcc</tt></title></HEADER>
<BODY>

<H1>Installing lcc</H1>

<b><a href="ftp://netlib.att.com/netlib/bibnet/people/f/fraser-chris.html">Christopher W. Fraser</a><br>
AT&T Bell Laboratories, 600 Mountain Avenue,
Murray Hill, NJ 07974<p>

<a href="http://www.cs.princeton.edu/faculty/drh/">David R. Hanson</a><br>
Department of Computer Science, Princeton University,
Princeton, NJ 08544</b><p>

<h2>Contents</h2>

<ol>
<li><a href="#intro">Introduction</a>
<li><a href="#paths">Paths</a>
<li><a href="#driver">Installing the Driver</a>
<li><a href="#rcc">Installing the Compiler Proper</a>
<li><a href="#bugs">Reporting Bugs</a>
<li><a href="#mailinglist">Keeping in Touch</a>
</ol>

<h2><a name="intro">1. Introduction</a></h2>

<a href="http://www.cs.princeton.edu/software/lcc/"><tt>lcc</tt></a>
is the ANSI C compiler described in our book
<cite>A Retargetable C Compiler: Design and Implementation</cite>
(Benjamin Cummings, 1995, ISBN 0-8053-1670-1).<p>

Extract the distribution into its own directory.
All paths below are relative to this directory.
The distribution holds the following subdirectories.
<dl>
<dt><tt>src</tt>		<dd>source code
<dt><tt>etc</tt>		<dd>driver, man page
<dt><tt>doc</tt>		<dd>this document
<dt><tt>include</tt>		<dd>ANSI include files
<dt><tt>tst</tt>		<dd>test suite
<dt><tt>mips-* mips-*/tst</tt>	<dd>MIPS build area, test output
<dt><tt>sparc-* sparc-*/tst</tt><dd>SPARC build area directory, test output
<dt><tt>x86-dos x86-dos/tst</tt><dd>x86 build area, test output
<dt><tt>vax-bsd vax-bsd/tst</tt><dd>symbolic test output
</dl>
Distributions include code generators for the MIPS, SPARC,
and the Intel 386 and its successors.<p>

Installation involves three steps performed in the following order.<p>
<ol>
<li>Decide where to install the man page, the include files,
the compiler, and <tt>lcc</tt>, the driver program;
see <a href="#paths">Sec. 2</a>.<p>

<li>Install a host-specific driver;
see <a href="#driver">Sec. 3</a>.<p>

<li>Install the compiler;
see <a href="#rcc">Sec. 4</a>.<p>
</ol>

The constant <tt>VERSION</tt>,
defined in <tt>src/c.h</tt>, identifies the version of the distribution
as <tt>((<i>x</i>&lt;&lt;8)|<i>y</i>)</tt>
for version <tt><i>x</i>.<i>y</i></tt>.
If the file <tt>LOG</tt> appears, it
describes the changes from the previous version.<p>

<tt>doc/install.html</tt> is the HTML file for this document.
<tt>doc/install.ps</tt> and <tt>doc/install.txt</tt>
are PostScript and plain ASCII versions.<p>

<h2><a name="paths">2. Paths</a></h2>

Installation consists of three files and one directory;
these are summarized below along with paths used in typical installations.
<dl>
<dt><tt>/usr/local/man/man1/lcc.1</tt>	<dd>the man page
<dt><tt>/usr/local/lib/rcc</tt>		<dd>the compiler
<dt><tt>/usr/local/bin/lcc</tt>		<dd>the driver
<dt><tt>/usr/local/include/ansi</tt>	<dd>include files (a directory)
</dl>
These files can be placed in other, site-specific locations,
but the compiler should be named <tt>rcc</tt>.
If the driver isn't named <tt>lcc</tt>,
edit the man page (<tt>etc/lcc.1</tt>).<p>

Include files are in directories named
<tt>include/</tt><i>target</i><tt>-</tt><i>system</i>;
the meaningful combinations are
<dl>
<dt><tt>mips-irix</tt>		<dd>IRIX Release 4.0
<dt><tt>mips-ultrix</tt>	<dd>ULTRIX 4.3
<dt><tt>sparc-sun</tt>		<dd>SunOS 4.1
<dt><tt>sparc-solaris</tt>	<dd>Solaris 2.3
<dt><tt>x86-dos</tt>		<dd>DOS 6.0, Windows 3.1
<dt><tt>vax-bsd</tt>
</dl>
The <tt>vax-bsd</tt> combination exists only to test a symbolic
code generator; there is no VAX code generator.
Choose the include files that are appropriate for your system,
or make a copy of a closely related set and edit them.<p>

For example, if the paths shown above are chosen and if
<tt>include/mips-ultrix</tt> has the appropriate include files,
install the man page and include files by
<pre>% cp etc/lcc.1 /usr/local/man/man1
% cp include/mips-ultrix/*.h /usr/local/include/ansi
</pre>

<h2><a name="driver">3. Installing the Driver</a></h2>

The preprocessor, compiler, assembler, and loader are
invoked by a driver program, <tt>lcc</tt>, which is similar
to <tt>cc</tt> on most systems. It's described in the man page
<tt>etc/lcc.1</tt>.
The driver is built by combining the host-independent
part, <tt>etc/lcc.c</tt>, with a small host-specific part.
By convention, host-specific parts are named <i>hostname</i><tt>.c</tt>,
where <i>hostname</i> is the local name for the host on which <tt>lcc</tt>
is being installed. <tt>etc</tt> holds many examples.
Comments in most give the details of the
particular host; pick one that is closely related to your host,
copy it to <tt>etc/</tt><i>yourhostname</i><tt>.c</tt>,
and edit it as described below.
You should not have to edit <tt>etc/lcc.c</tt>.<p>

Debug your version of the driver by running it
with the <tt>-v -v</tt> options, which cause it to echo the
commands it would execute, but not to execute them.<p>

Here's <tt>etc/hart.c</tt>, which we'll use as an example
in describing how to edit a host-specific part.
This example illustrates all of the important features.
<pre>/* DECStations running ULTRIX at Princeton University */

#include &lt;string.h&gt;

char *cpp[] = {
        "/usr/gnu/lib/gcc-cpp", "-undef",
        "-DLANGUAGE_C", "-D_LANGUAGE_C", "-D__LANGUAGE_C",
        "-D_unix", "-D__unix", "-Dultrix", "-D_ultrix", "-D__ultrix",
        "-Dmips", "-D_mips", "-D__mips",
        "-Dhost_mips", "-D_host_mips", "-D__host_mips",
        "-DMIPSEL", "-D_MIPSEL", "-D__MIPSEL",
        "$1", "$2", "$3", 0 };
char *include[] = { "-I/usr/local/include/ansi", 0 };
char *com[] =  { "/usr/local/lib/rcc", "-target=mips-ultrix",
        "$1", "$2", "$3", 0 };
char *as[] =  { "/bin/as", "-o", "$3", "", "$1",
        "-nocpp", "-EL", "$2", 0 };
char *ld[] =  { "/usr/bin/ld", "-o", "$3", "/usr/lib/crt0.o",
        "$1", "$2", "", "", "-lm", "-lc", 0 };

int option(arg) char *arg; {
        if (strcmp(arg, "-g") == 0)
                as[3] = "-g";
        else if (strcmp(arg, "-p") == 0
        && strcmp(ld[3], "/usr/lib/crt0.o") == 0) {
                ld[3] = "/usr/lib/mcrt0.o";
                ld[7] = "/usr/lib/libprof1.a";
        } else if (strcmp(arg, "-b") == 0
        && access("/usr/local/lib/bbexit.o", 4) == 0)
                ld[6] = "/usr/local/lib/bbexit.o";
        else
                return 0;
        return 1;
}
</pre>

Most of the host-specific code is data that
gives prototypes for the commands that invoke
the preprocessor, compiler, assembler, and loader.
Each command prototype is an array of pointers to strings
terminated with a null pointer;
the first string is the full path name of the command and the others
are the arguments or argument placeholders, which are described below.<p>

The <tt>cpp</tt> array gives the command for running the preprocessor.
<tt>lcc</tt> is intended to be used with an ANSI preprocessor,
such as the GNU C preprocessor available from the Free Software Foundation.
If the GNU preprocessor is used,
it must be named <tt>gcc-cpp</tt> in order for <tt>lcc</tt>'s <tt>-N</tt> option
to work correctly.<p>

Literal arguments specified in prototypes, e.g., <tt>"-Dmips"</tt> in
the <tt>cpp</tt> command above, are passed to the command as given.<p>

The strings <tt>"$1"</tt>, <tt>"$2"</tt>, and <tt>"$3"</tt> in
prototypes are placeholders for <em>lists</em> of arguments that
are substituted in a copy of the prototype before the command is executed.
<tt>$1</tt> is replaced by the <em>options</em> specified by the user;
for the preprocessor, this list always contains at least
<tt>-Dunix</tt> and <tt>-D__LCC__</tt>.
<tt>$2</tt> is replaced by the <em>input</em> files,
and <tt>$3</tt> is replaced by the <em>output</em> file.<p>

Zero-length arguments after replacement are removed from
the argument list before the command is invoked. So, e.g.,
if the preprocessor is invoked without an output file,
<tt>"$3"</tt> becomes <tt>""</tt>, which is removed from the final argument list.<p>

For example, to specify a preprocessor command prototype to invoke
<tt>/bin/cpp</tt> with the options <tt>-Dmips</tt> and <tt>-Dultrix</tt>,
the <tt>cpp</tt> array would be
<pre>char *cpp[] = { "/bin/cpp", "-Dmips", "-Dultrix",
        "$1", "$2", "$3", 0 };
</pre>

The <tt>include</tt> array is a list of <tt>-I</tt> options that
specify which directives should be searched to satisfy include directives.
These directories are searched in the order given.
The first directory should be the one to which the ANSI
header files were copied in <a href="#paths">Sec. 2</a>.
The driver adds these options to <tt>cpp</tt>'s arguments
when it invokes the preprocessor, except when <tt>-N</tt> is specified.<p>

Design this list carefully. Mixing ANSI and pre-ANSI headers (e.g., by
listing <tt>/usr/include</tt> after the directory of ANSI headers
shown above) may mix incompatible headers.
Unless the default list holds <em>only</em>
<tt>/usr/include</tt> or <em>only</em> the ANSI headers, many users may be
forced to use <tt>-N</tt> and <tt>-I</tt> incessantly.<p>

<tt>com</tt> gives the command for invoking the compiler.
This prototype can appear as shown above, with two important
changes. The command name should be edited to reflect the
location of the compiler chosen in <a href="#paths">Sec. 2</a>,
and the option <tt>-target=mips-ultrix</tt> should be edited
to the <i>target</i><tt>-</tt><i>system</i> for your host.
<tt>lcc</tt> can generate
code for <em>all</em> of the <i>target</i><tt>-</tt><i>system</i>
combinations listed in <a href="#paths">Sec. 2</a>. The <tt>-target</tt>
option specifies the default combination. The driver's <tt>-Wf</tt> option
can be used to specify other combinations;
the <a href="lcc.1.html">man page</a> elaborates.<p>

<tt>as</tt> gives the command for invoking the assembler.<p>

<tt>ld</tt> gives the command for invoking the loader.
For the other commands, the list <tt>$2</tt> contains a single file;
for <tt>ld</tt>, <tt>$2</tt> contains all `.o' files and libraries, and
<tt>$3</tt> is <tt>a.out</tt>, unless the <tt>-o</tt> option is specified.
As suggested in the code above, <tt>ld</tt> must also specify
the appropriate startup code and default libraries.<p>

The <tt>option</tt> function is described below;
for now, use an existing <tt>option</tt> function or one that returns 0.<p>

After specifying the prototypes, compile the driver by
<pre>% cd etc
% make HOST=hart
</pre>
where <tt>hart</tt> is replaced by <i>yourhostname</i>.
Run the resulting <tt>a.out</tt> with the options <tt>-v -v</tt>
to display the commands that would be executed, e.g.,
<pre>% a.out -v -v foo.c baz.c mylib.a -lX11
a.out version 3.0
foo.c:
/usr/gnu/lib/gcc-cpp -undef -DLANGUAGE_C -D_LANGUAGE_C -D__LANGUAGE_C
   -D_unix -D__unix -Dultrix -D_ultrix -D__ultrix -Dmips -D_mips
   -D__mips -Dhost_mips -D_host_mips -D__host_mips -DMIPSEL -D_MIPSEL
   -D__MIPSEL -Dunix -D__LCC__ -v -I/usr/local/include/ansi foo.c
   | /usr/local/lib/rcc -target=mips-ultrix -v - /tmp/lcc12511.s
/bin/as -o foo.o -nocpp -EL /tmp/lcc12511.s
baz.c:
/usr/gnu/lib/gcc-cpp -undef -DLANGUAGE_C -D_LANGUAGE_C -D__LANGUAGE_C
   -D_unix -D__unix -Dultrix -D_ultrix -D__ultrix -Dmips -D_mips
   -D__mips -Dhost_mips -D_host_mips -D__host_mips -DMIPSEL -D_MIPSEL
   -D__MIPSEL -Dunix -D__LCC__ -v -I/usr/local/include/ansi baz.c
   | /usr/local/lib/rcc -target=mips-ultrix -v - /tmp/lcc12511.s
/bin/as -o baz.o -nocpp -EL /tmp/lcc12511.s
/usr/bin/ld -o a.out /usr/lib/crt0.o foo.o baz.o mylib.a -lX11 -lm -lc
rm /tmp/lcc12511.s
</pre>
Leading spaces indicate lines that have been folded manually to fit this page.
Note the use of a pipeline to connect the preprocessor and compiler.
<tt>lcc</tt> arranges this pipeline itself; it does not call the shell.
If you want <tt>lcc</tt> to use temporary files instead of a pipeline,
define <tt>PIPE=0</tt> in <tt>CFLAGS</tt> when making the driver:
<pre>% make CFLAGS='-DPIPE=0' HOST=hart
</pre>
The option <tt>-pipe</tt> forces <tt>lcc</tt>
to use a pipeline between the preprocessor and the compiler
regardless of <tt>PIPE</tt>'s value.<p>
 
As the output shows, <tt>lcc</tt> places temporary files in <tt>/tmp</tt>.
Alternatives can be specified by defining <tt>TEMPDIR</tt> in <tt>CFLAGS</tt>
when making the driver, e.g.,
<pre>% make CFLAGS='-DTEMPDIR=\"/usr/tmp\"' HOST=hart
</pre>
causes <tt>lcc</tt> to place temporary files in <tt>/usr/tmp</tt>.

Once the driver is completed, install it by
<pre>% cp a.out /usr/local/bin/lcc
</pre>
where the destination is the location chosen for <tt>lcc</tt>
in <a href="#paths">Sec. 2</a>.<p>

The <tt>option</tt> function is called for the options
<tt>-g</tt>, <tt>-p</tt>, <tt>-pg</tt>, and <tt>-b</tt> because
these compiler options might also affect the loader's arguments.
For these options,
the driver calls <tt>option(arg)</tt> to give the host-specific
code an opportunity to edit the <tt>ld</tt> command, if necessary.
<tt>option</tt> can change <tt>ld</tt>, if necessary, and return 1 to
announce its acceptance of the option. If the option
is unsupported, <tt>option</tt> should return 0.<p>

For example, in response to <tt>-g</tt>, the <tt>option</tt> function shown above
changes <tt>as[3]</tt> from <tt>""</tt> to <tt>"-g"</tt>, which specifies
the debugging option to the assembler. If <tt>-g</tt> is not specified,
the <tt>""</tt> argument is omitted from the <tt>as</tt> command
because it's empty.<p>

Likewise, the <tt>-p</tt> causes <tt>option</tt> to change the name
of the startup code and add the name of the profiling library. Note that
<tt>option</tt> has been written to support simultaneous use
of <tt>-g</tt> and <tt>-p</tt>, e.g.,
<pre>% a.out -v -v -g -p foo.s baz.o -o myfoo
a.out version 3.0
/bin/as -o foo.o -g -nocpp -EL foo.s
/usr/bin/ld -o myfoo /usr/lib/mcrt0.o foo.o baz.o
   /usr/lib/libprof1.a -lm -lc
rm /tmp/lcc12516.s
</pre>
On Suns, the driver also
recognizes <tt>-Bstatic</tt> and <tt>-Bdynamic</tt> as linker options,
and recognizes but ignores Sun's `<tt>-target</tt> <i>name</i>' option.<p>

The option <tt>-Wo</tt><i>arg</i> causes the driver to pass <i>arg</i>
to <tt>option</tt>. Such options have no other effect; this mechanism
is provided to support system-specific options that affect the
commands executed by the driver.<p>

The <tt>-b</tt> option causes the compiler to generate
code to count the number of times each expression is executed.
The <tt>exit</tt> function in <tt>etc/bbexit.c</tt> writes these
counts to <tt>prof.out</tt> when the program terminates.
If <tt>option</tt> is called with <tt>-b</tt>,
it must edit the <tt>ld</tt> command accordingly,
as shown above. This version of <tt>option</tt> uses
the <tt>access</tt> system call to insure that <tt>bbexit.o</tt> is installed before
editing the <tt>ld</tt> command. To install <tt>bbexit.o</tt> execute
<pre>% make bbexit.o
% cp bbexit.o /usr/local/lib/bbexit.o
</pre>
If necessary, change <tt>/usr/local/lib</tt> to reflect local conventions.
The <tt>exit</tt> function in <tt>etc/bbexit.c</tt> works on the
systems listed in <a href="#paths">Sec. 2</a>,
but may need to be modified for other systems.<p>

If <tt>option</tt> supports <tt>-b</tt>, you should also
install <tt>etc/bprint.c</tt>, which reads <tt>prof.out</tt>
and generates a listing annotated with execution counts.
After <tt>lcc</tt> is installed, install <tt>bprint</tt> with the commands
<pre>% make bprint
% cp bprint /usr/local/bin/bprint
% cp bprint.1 /usr/local/man/man1
</pre>
The <tt>makefile</tt> uses <tt>lcc</tt> to compile <tt>bprint.c</tt>;
you must use <tt>lcc</tt> or another ANSI C compiler, e.g., <tt>gcc</tt>,
because <tt>bprint.c</tt> is written in ANSI C.
Also, <tt>bprint.c</tt> <em>includes</em> <tt>"../src/profio.c"</tt>, so it must
be compiled in <tt>etc</tt>.<p>

To complete the driver,
write an appropriate <tt>option</tt> function for your system,
and make and install the driver as described above.<p>

<h2><a name="rcc">4. Installing the Compiler Proper</a></h2>

The compiler proper, <tt>rcc</tt>, is built by compiling it
with the host C compiler and then using the result to re-compile itself.
A test suite is used to
verify that the compiler is working correctly.
The examples below illustrate this process on a MIPS under Ultrix.
You must have the driver, <tt>lcc</tt>, installed in order
to test <tt>rcc</tt>.
If any of the steps below fail, contact us
(see <a href="#bugs">Sec. 5</a>).<p>

The object files, <tt>rcc</tt>, and the generated code for
the programs in the test suite are placed in the directory
<i>target-system</i> where <i>target</i> and <i>system</i>
are the names of your target machine and its operating system, respectively.
There are directories for the supported
<i>target-system</i> combinations, e.g., <tt>mips-ultrix</tt>.<p>

The default target in <tt>src/makefile</tt> is <tt>rcc</tt>.
<tt>lcc</tt> is built by executing <tt>make</tt> from the
apppropriate <i>target-system</i> directory
and specifying system-specific values for <tt>CFLAGS</tt> and <tt>LDFLAGS</tt>,
if necessary.
For example, to build <tt>rcc</tt> for a MIPS running Ultrix,
execute the commands
<pre>% cd mips-ultrix
% make -f ../src/makefile
cc -c -O ../src/alloc.c
...
cc -c -O ../src/x86.c
cc -o rcc  alloc.o bind.o dag.o ... mips.o sparc.o x86.o
</pre>
There may be a few warnings, but there should be no errors.
If your host is an SGI machine running IRIX 4.0 or later,
you might need <tt>CFLAGS=-cckr</tt>.
If <tt>cc</tt> doesn't automatically search the directory that holds
the source file, specify <tt>CFLAGS=-I../src</tt>.
If you use <tt>gcc</tt>, specify <tt>CFLAGS="-ansi -fno-builtin"</tt>.<p>

Once <tt>rcc</tt> is built with the host C compiler,
run the test suite to verify that <tt>rcc</tt> is working correctly.
The commands in <tt>src/makefile</tt> run the shell script
<tt>src/run</tt> on each C program in the test suite, <tt>tst/*.c</tt>.
It uses the driver, <tt>lcc</tt>, so you must
have the driver installed before testing <tt>rcc</tt>.
The <i>target</i><tt>-</tt><i>system</i> combination is read from the
variable <tt>TARGET</tt>, which is specified when invoking <tt>make</tt>:
<pre>% make -f ../src/makefile TARGET=mips-ultrix test
../rcc mips-ultrix 8q:
../rcc mips-ultrix array:
../rcc mips-ultrix cf:
../rcc mips-ultrix cq:
../rcc mips-ultrix cvt:
../rcc mips-ultrix fields:
../rcc mips-ultrix front:
../rcc mips-ultrix incr:
../rcc mips-ultrix init:
../rcc mips-ultrix limits:
../rcc mips-ultrix paranoia:
../rcc mips-ultrix sort:
../rcc mips-ultrix spill:
../rcc mips-ultrix stdarg:
../rcc mips-ultrix struct:
../rcc mips-ultrix switch:
../rcc mips-ultrix wf1:
../rcc mips-ultrix yacc:
</pre> 
For each C program in the test suite,
<tt>src/run</tt> compiles the program and uses <tt>diff</tt>
to compare the generated assembly code
with the expected code (the MIPS code expected for <tt>tst/8q.c</tt> is
in <tt>mips-ultrix/tst/8q.s.bak</tt>, etc.).
If there are differences, the script
executes the generated code with the input given in <tt>tst</tt>
(the input for <tt>tst/8q.c</tt> is in <tt>tst/8q.0</tt>, etc.)
and compares the output with the expected output
(the expected output from <tt>tst/8q.c</tt> on the MIPS is
in <tt>mips-ultrix/tst/8q.1.bak</tt>, etc.). The script also compares the
diagnostics from the compiler with the expected diagnostics.<p>

On some systems, there may be a few differences between the generated code
and the expected code.
These differences occur because the expected code is
generated by cross compilation
on a MIPS and the least-significant bits of some floating-point constants
differ from those bits in constants generated on your system.
There should be no differences in the output from executing the test programs.<p>

The <tt>../rcc</tt> and <tt>mips-ultrix</tt> preceding the name of
each test program in the output
above indicate the compiler and the target, e.g.,
`<tt>../rcc</tt> is generating code for a <tt>mips</tt> running the
<tt>ultrix</tt> operating system.'<p>

Next, build <tt>rcc</tt> again using the just-built <tt>rcc</tt>:
<pre>% make -f ../src/makefile TARGET=mips-ultrix triple
rm -f *.o
make -f ../src/makefile CC='lcc -B./ -d0.1 -A'
   CFLAGS='-Wf-target=mips-ultrix -I../src/../include/mips-ultrix
   -I../src'  LDFLAGS=''
lcc -B./ -d0.1 -A -c -Wf-target=mips-ultrix
   -I../src/../include/mips-ultrix -I../src ../src/alloc.c
...
lcc -B./ -d0.1 -A -o rcc  alloc.o bind.o dag.o decl.o ... x86.o
strip rcc
od +8 <rcc >od2
rm -f *.o
make -f ../src/makefile CC='lcc -B./ -d0.1 -A'
   CFLAGS='-Wf-target=mips-ultrix -I../src/../include/mips-ultrix
   -I../src'  LDFLAGS=''
lcc -B./ -d0.1 -A -c -Wf-target=mips-ultrix
   -I../src/../include/mips-ultrix -I../src ../src/alloc.c
...
lcc -B./ -d0.1 -A -o rcc  alloc.o bind.o dag.o decl.o ... x86.o
strip rcc
od +8 <rcc >od3
cmp od[23] && rm od[23]
</pre>
This command builds <tt>rcc</tt> twice; once using the
<tt>rcc</tt> built by <tt>cc</tt>
and again using the <tt>rcc</tt> built by <tt>lcc</tt>.
After building each version, an octal dump of the resulting binary is made,
and the two dumps are compared. They should be identical, as shown
at the end of the output above.
If they aren't, our compiler is generating bad code;
<a href="#bugs">contact</a> us.<p>

The final version of <tt>rcc</tt> should also pass the test suite;
i.e., the output from
<pre>make -f ../src/makefile TARGET=mips-ultrix test
</pre>
should be identical to that from the previous <tt>make test</tt>.<p>

Now install the final version of <tt>rcc</tt>:
<pre>% cp rcc /usr/local/lib/rcc
</pre>
where the destination is the location chosen for <tt>rcc</tt>
in <a href="#paths">Sec. 2</a>.<p>

On some systems, you may be able
to use environment variables and <tt>make</tt>'s <tt>-e</tt>
option to avoid specifying <tt>TARGET</tt>
on each <tt>make</tt> command, and
the <tt>make</tt> commands described above can be done with a single command:
<pre>% setenv TARGET mips-ultrix
% cd mips-ultrix
% make -e -f ../src/makefile test triple test clean
</pre>
<tt>make clean</tt> cleans up, but does not remove <tt>rcc</tt>, and
<tt>make clobber</tt> cleans up and removes <tt>rcc</tt>.<p>

Setting <tt>TARGET</tt> equal to <tt>vax-bsd</tt> causes <tt>rcc</tt>
to generate code for a `symbolic' target.
This target is used routinely in front-end development, and
its output is a printable representation of the input program,
e.g., the dags constructed by the front end are printed,
and other interface functions print their arguments.<p>

You can test the symbolic target by running <tt>make</tt>
from the <tt>vax-bsd</tt> directory and setting some
environment variables to control what <tt>src/run</tt> does.
For example, if you built <tt>mips-ultrix/rcc</tt>, you can
test the symbolic target as follows.
<pre>% setenv REMOTEHOST noexecute
% setenv BUILDDIR /usr/local/lib/
% cd vax-bsd
% make -f ../src/makefile RCC= TARGET=vax-bsd test
/usr/local/lib/rcc vax-bsd 8q:
/usr/local/lib/rcc vax-bsd array:
/usr/local/lib/rcc vax-bsd cf:
/usr/local/lib/rcc vax-bsd cq:
/usr/local/lib/rcc vax-bsd cvt:
/usr/local/lib/rcc vax-bsd fields:
/usr/local/lib/rcc vax-bsd front:
/usr/local/lib/rcc vax-bsd incr:
/usr/local/lib/rcc vax-bsd init:
/usr/local/lib/rcc vax-bsd limits:
/usr/local/lib/rcc vax-bsd paranoia:
/usr/local/lib/rcc vax-bsd sort:
/usr/local/lib/rcc vax-bsd spill:
/usr/local/lib/rcc vax-bsd stdarg:
/usr/local/lib/rcc vax-bsd struct:
/usr/local/lib/rcc vax-bsd switch:
/usr/local/lib/rcc vax-bsd wf1:
/usr/local/lib/rcc vax-bsd yacc:
</pre>
As above, <tt>src/run</tt> compares the
symbolic code generated with what's expected.
There should be no differences.
Setting <tt>REMOTEHOST</tt> to <tt>noexecute</tt> suppresses
the assembly and execution of the generated code.
<tt>BUILDDIR</tt> gives the directory that holds <tt>rcc</tt>,
and specifying <tt>RCC=</tt> to <tt>make</tt> insures that
<tt>rcc</tt> is not rebuilt in the <tt>vax-bsd</tt> directory.<p>

Similar commands can be used to test the other code generators.
For example,
<pre>% setenv REMOTEHOST noexecute
% setenv BUILDDIR /usr/local/lib/
% cd sparc-sun
% make -f ../src/makefile RCC= TARGET=sparc-sun test
</pre>
tests the SPARC code generator for SunOS. If you set <tt>REMOTEHOST</tt>
to the name of a SPARC machine to which you can <tt>rlogin</tt>,
<tt>src/run</tt> will <tt>rcp</tt> the generated code to that machine
and execute it there, if necessary. See <tt>src/run</tt> for the details.<p>

<h2><a name="bugs">5. Reporting Bugs</a></h2>

<tt>lcc</tt> is a large, complex program.
We find and repair errors routinely. If you think
that you've found a error, follow the steps below, which are
adapted from the instructions in Chapter 1 of
<cite>A Retargetable C Compiler: Design and Implementation</cite>.<p>

<ol>
<li>If you don't have a source file that displays the error, create one.
Most errors are exposed when programmers try to compile
a program that they think valid, so you probably have a
demonstration program already.<p>

<li>Preprocess the source file and capture the preprocessor output.
Discard the original code.<p>

<li>Prune your source code until it can be pruned no more without
sending the error into hiding.
We prune most error demonstrations to fewer than five lines.<p>

<li>Confirm that the source file displays the error with the
<em>distributed</em> version of <tt>lcc</tt>. If you've changed <tt>lcc</tt>,
and if the error appears only in your version, then you'll have to chase the error
yourself, even if it turns out to be our fault, because we
can't work on your code.<p>

<li>Annotate your code with comments that explain why you think that
<tt>lcc</tt> is wrong. If <tt>lcc</tt> dies with an assertion failure, please tell us
where it died. If <tt>lcc</tt> crashes, please report the last part of the
call chain if you can. If <tt>lcc</tt> is rejecting a program that you think
valid, please tell us why you think it's valid, and include
supporting page numbers in the ANSI Standard, Appendix A in
<cite>The C Programming Language</cite>, 2nd edition
by B. W. Kernighan and D. M. Ritchie (Prentice Hall, 1988),
or the appropriate section in <cite>C, A Reference Manual</cite>, 3rd edition
by S. B. Harbison and G. L. Steele, Jr. (Prentice Hall, 1991).
If <tt>lcc</tt> silently generates incorrect code for some
construct, please include the corrupt assembly code in the comments
and flag the bad instructions if you can.<p>

<li>Confirm that your error hasn't been fixed already. The latest
version of <tt>lcc</tt> is always available for anonymous <tt>ftp</tt> from
<tt>ftp.cs.princeton.edu</tt> in
<a href="ftp://ftp.cs.princeton.edu/pub/lcc"><tt>pub/lcc</tt></a>.
A <a href="ftp://ftp.cs.princeton.edu/pub/lcc/README"><tt>README</tt></a>
file there gives acquistion details,
and a <a href="ftp://ftp.cs.princeton.edu/pub/lcc/LOG"><tt>LOG</tt></a>
file reports what errors were fixed
and when they were fixed. If you report a error that's been fixed,
you might get a canned reply.<p>

<li>Send your program by electronic mail to
<tt>lcc-bugs@cs.princeton.edu</tt>. Please send only valid C programs;
put all remarks in C comments so that we can process reports
semi-automatically.<p>

</ol>

<h2><a name="mailinglist">6. Keeping in Touch</a></h2>

There is an <tt>lcc</tt> mailing list.
To be added to the list, send a message with the 1-line body 
<pre>subscribe lcc
</pre>
to <tt>majordomo@cs.princeton.edu</tt>.
This line must appear in the message body;
`Subject:' lines are ignored.
To learn more about mailing lists served by <tt>majordomo</tt>,
send a message with the 1-word body <tt>`help'</tt>
to <tt>majordomo@cs.princeton.edu</tt>.

Mail sent to <tt>lcc@cs.princeton.edu</tt> and to <tt>lcc-bugs@cs.princeton.edu</tt>
is forwarded to everyone on the mailing list.<p>

<hr>

<address>
<a href="ftp://netlib.att.com/netlib/bibnet/people/f/fraser-chris.html">Chris Fraser</a>
/ cwf@research.att.com</a>
</address>
<address>
<a href="/faculty/drh">David Hanson</a> / drh@cs.princeton.edu
</address>
<address>
Sun Jul 31 11:48:38 EDT 1994
</address>
</BODY>
